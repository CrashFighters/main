const fs=require("fs"),readdirSync=fs.readdirSync,writeFileSync=fs.writeFileSync,settings=require("../../../settings.json");module.exports={execute(e,r){try{let t=e.stack;void 0===t&&(`${e}`?t=new Error(`${e}`).stack:(e=new Error("Error message is undefined"),t=e.stack));let s,i=!0;if(readdirSync(settings.generic.path.files.errors).forEach((e=>{if(e===settings.generic.path.files.noError)return;require(`../../.${settings.generic.path.files.errors}${e}`).errorMessage.split(": ")[1]===t.split("\n")[0].split(": ")[1]&&(i=!1,s=e)})),i){const e=(new Date).getTime(),s=`${Math.floor(1e8*Math.random())}.json`,i=`${settings.generic.path.files.errors}${s}`,n={errorMessage:t.split("\n")[0],occurrences:[{time:e,stack:t.split("\n")}]};let c=null;try{c=t.split("\n")[1].split("(")[1].split(")")[0]}catch{}return c&&(n.occurrences[0].easyAccesPath=c),r&&(n.occurrences[0].customText=r),writeFileSync(i,JSON.stringify(n)),`${s}`}{const e=(new Date).getTime(),i=`../../.${settings.generic.path.files.errors}${s}`,n=`${settings.generic.path.files.errors}${s}`,c=require(i),l={time:e,stack:t.split("\n")};let a=null;try{a=t.split("\n")[1].split("(")[1].split(")")[0]}catch{}return a&&(l.easyAccesPath=a),r&&(l.customText=r),c.occurrences.push(l),writeFileSync(n,JSON.stringify(c)),s}}catch(e){require("./lastFallback").execute(e)}}};
