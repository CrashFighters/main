const fs=require("fs"),readdirSync=fs.readdirSync,writeFileSync=fs.writeFileSync,settings=require("../../../settings.json");function createEasyAccessPath(e){try{const r=e.split("\n").slice(1).filter((e=>e.includes("at"))).filter((e=>!e.includes("internal"))).filter((e=>!e.includes("node:"))).filter((e=>!e.includes("<anonymous>"))).filter((e=>!e.includes("node_modules")))[0]?.split?.("(")?.[1]?.split?.(")")?.[0];return r}catch{}}module.exports={execute(e,r){try{let s=e.stack;void 0===s&&(`${e}`?s=new Error(`${e}`).stack:(e=new Error("Error message is undefined"),s=e.stack));let t,i=!0;if(readdirSync(settings.generic.path.files.errors).forEach((e=>{if(e===settings.generic.path.files.noError)return;require(`../../.${settings.generic.path.files.errors}${e}`).errorMessage.split(": ")[1]===s.split("\n")[0].split(": ")[1]&&(i=!1,t=e)})),i){const e=(new Date).getTime(),t=`${Math.floor(1e8*Math.random())}.json`,i=`${settings.generic.path.files.errors}${t}`,n={errorMessage:s.split("\n")[0],occurrences:[{time:e,stack:s.split("\n")}]},c=createEasyAccessPath(s);return c&&(n.occurrences[0].easyAccessPath=c),r&&(n.occurrences[0].customText=r),writeFileSync(i,JSON.stringify(n,null,4)),`${t}`}{const i=(new Date).getTime(),n=`../../.${settings.generic.path.files.errors}${t}`,c=`${settings.generic.path.files.errors}${t}`,a=require(n),l={time:i,stack:s.split("\n")},o=createEasyAccessPath(e);return o&&(l.easyAccessPath=o),r&&(l.customText=r),a.occurrences.push(l),writeFileSync(c,JSON.stringify(a,null,4)),t}}catch(e){require("./lastFallback").execute(e)}}};
